
options {
  LOOKAHEAD = 1;
  IGNORE_CASE = true;
  STATIC = false;
  USER_TOKEN_MANAGER=false;
  USER_CHAR_STREAM=false;

  // JJTree options

  MULTI=true;
  NODE_DEFAULT_VOID = true;
}

PARSER_BEGIN(JSONSSParser)

package org.metadatacenter.jsonss.parser;

import org.metadatacenter.jsonss.core.settings.ReferenceSettings;

import java.util.*;

public class JSONSSParser 
{
  private int defaultReferenceType;
  private String defaultLocationValue;
  private String defaultLiteralValue;
  private int defaultEmptyLocationSetting;
  private int defaultEmptyLiteralSetting;
  private int defaultShiftSetting;
  
  public JSONSSParser(java.io.InputStream stream, ReferenceSettings referenceSettings, int unused)
  {
    this(stream);
    updateDefaultReferenceSettings(referenceSettings);
  }

  public void updateDefaultReferenceSettings(ReferenceSettings referenceSettings)
  {
    defaultLocationValue = referenceSettings.getDefaultLocationValue();
    defaultLiteralValue = referenceSettings.getDefaultLiteralValue();
    defaultReferenceType = referenceSettings.getReferenceTypeSetting().getConstant();
    defaultShiftSetting = referenceSettings.getShiftSetting().getConstant();
    defaultEmptyLocationSetting = referenceSettings.getEmptyLocationSetting().getConstant();
    defaultEmptyLiteralSetting = referenceSettings.getEmptyLiteralSetting().getConstant();
  }
}

PARSER_END(JSONSSParser)

/* White space */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* Comments */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN: { <JSONSS_BOOLEAN: "boolean" > }
TOKEN: { <JSONSS_STRING: "string" > }
TOKEN: { <JSONSS_INTEGER: "integer" > }
TOKEN: { <JSONSS_NUMERIC: "numeric" > }

// JSON-SS Tokens

TOKEN: { <CELL_WILDCARD: "*"> }
TOKEN: { <EXCLAMATION_POINT: "!"> }
TOKEN: { <COMMA: ","> }
TOKEN: { <COLON: ":"> }
TOKEN: { <EQUAL: "="> }
TOKEN: { <AT: "@"> }
TOKEN: { <OPEN_PAREN: "("> }
TOKEN: { <CLOSE_PAREN: ")"> }
TOKEN: { <OPEN_BRACE: "{"> }
TOKEN: { <CLOSE_BRACE: "}"> }
TOKEN: { <OPEN_BRACKET: "["> }
TOKEN: { <CLOSE_BRACKET: "]"> }

TOKEN: { <LOCATION: "Location"> }

TOKEN: { <TRUE: "true" | "TRUE">}
TOKEN: { <FALSE: "false" | "FALSE">}
TOKEN: { <NULL: "null" > }

TOKEN: { <NO_SHIFT: "NoShift"> }
TOKEN: { <SHIFT_UP: "ShiftUp"> }
TOKEN: { <SHIFT_DOWN: "ShiftDown"> }
TOKEN: { <SHIFT_LEFT: "ShiftLeft"> }
TOKEN: { <SHIFT_RIGHT: "ShiftRight"> }

TOKEN: { <ERROR_IF_EMPTY_LOCATION: "ErrorIfEmptyLocation"> }
TOKEN: { <WARNING_IF_EMPTY_LOCATION: "WarningIfEmptyLocation"> }
TOKEN: { <SKIP_IF_EMPTY_LOCATION: "SkipIfEmptyLocation"> }
TOKEN: { <PROCESS_IF_EMPTY_LOCATION: "ProcessIfEmptyLocation"> }

TOKEN: { <PROCESS_IF_EMPTY_LITERAL: "ProcessIfEmptyLiteral"> }
TOKEN: { <ERROR_IF_EMPTY_LITERAL: "ErrorIfEmptyLiteral"> }
TOKEN: { <WARNING_IF_EMPTY_LITERAL: "WarningIfEmptyLiteral"> }
TOKEN: { <SKIP_IF_EMPTY_LITERAL: "SkipIfEmptyLiteral"> }

TOKEN: { <DEFAULT_LOCATION_VALUE: "DefaultLocationValue"> }
TOKEN: { <DEFAULT_LITERAL_VALUE: "DefaultLiteralValue"> }

TOKEN: { <TO_UPPER_CASE: "toUpperCase"> }
TOKEN: { <TO_LOWER_CASE: "toLowerCase"> }
TOKEN: { <TRIM: "trim"> }
TOKEN: { <CAPTURING: "capturing"> }
TOKEN: { <REVERSE: "reverse"> }
TOKEN: { <REPLACE: "replace"> }
TOKEN: { <REPLACE_ALL: "replaceAll"> }
TOKEN: { <REPLACE_FIRST: "replaceFirst"> }
TOKEN: { <APPEND: "append"> }
TOKEN: { <PREPEND: "prepend"> }

TOKEN: {
        <STRING: "\"" ( <ALLOWABLE_CHARACTERS> )* "\"" >
    |   <ALLOWABLE_CHARACTERS:(   
	        (~["\"", "\\", "\u0000"-"\u001f"])
	           | ("\\"
	            ( ["u"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"]
	                | ["\"", "\\", "b", "f", "n", "r", "t"]
	                )
	            )
	        )
	    >
}

TOKEN:
{
  <QUOTED_NAME_LITERAL: "'" (~["'"])* ("''" (~["'"])*)* "'" >
|
  <NUMBER:  <INTEGER> | <INTEGER> <FRACTIONAL_DIGITS> | <INTEGER> <EXPONENT> | <INTEGER> <FRACTIONAL_DIGITS> <EXPONENT> >
|
  <INTEGER: ("-") ? ( <DIGIT> | <NONZERO_DIGIT> <DIGITS>) >
|
  <FRACTIONAL_DIGITS: "." <DIGITS > >
|
  <#EXP: ["e", "E"] ( "+" | "-" )? >
|
  <EXPONENT: <EXP> <DIGITS> >
|
  <DIGITS: ( <DIGIT> )+ >
|
  <#LETTER: [ "a"-"z", "A"-"Z" ]>
|
  <#DIGIT: ["0"-"9"] >
| 
  <#NONZERO_DIGIT: ["1"-"9"] >
| 
  <LOCATION_SPECIFICATION: (<LETTER> | <DIGIT> | "_" | "-" | "#" | "." | ":" | "/" | "*" )+ | "'" (~["'"])* "'"> 
}

SimpleNode expression() #Expression : {}
{
  json_object() | json_array()
  {
     return jjtThis;
  }
}
void json_value() #JSONValue: {}
{
    (  json_object()
     | json_array()
     | json_boolean()
     | json_string()
     | json_number()
     | json_null()
    )
}

void json_array() #JSONArray : {}
{
  <OPEN_BRACKET> json_value() ( <COMMA> json_value() )* <CLOSE_BRACKET>
}

void json_object() #JSONObject : {}
{
   <OPEN_BRACE> json_key_value_pair() ( <COMMA> json_key_value_pair() )* <CLOSE_BRACE>
}

void json_key_value_pair() #JSONKeyValuePair: {}
{
  json_string() <COLON> json_value()
}

boolean json_boolean() #JSONBoolean: 
{
   boolean b;
}
{
  (   <TRUE> { b = Boolean.TRUE;}
    | <FALSE> { b = Boolean.FALSE;}
  )
  {
    jjtThis.value = b;
  }
}

void json_string() #JSONString: 
{
  Token t;
}
{
  t = <STRING> 

  {
    String s = t.image;
    jjtThis.value = s.substring(1, s.length() - 1);
  }
}

void json_number() #JSONNumber:
{
  Token t;
  Numeric n;
}
{
  t=<NUMBER>
        {
            try {
              n = Integer.valueOf(t.image);

            }
            catch (NumberFormatException nfe1) {
                try {
                    n = Long.valueOf(t.image);
                }
                catch (NumberFormatException nfe2) {
                    try {
                        n = Float.valueOf(t.image);
                    }
                    catch (NumberFormatException nfe3) {
                        try {
                            n = Double.valueOf(t.image);
                        }
                        catch  (NumberFormatException nfe4) {
                            n = Double.NaN;
                        }
                    }
                }

            }
        }
    {
      jjtThis.value = n;
    }
}

void json_null() #JSONNull : {}
{
  <NULL>
}

String jsonss_location_specification() :
{
  Token t;
}
{
  t = <LOCATION_SPECIFICATION>

  { return t.image; }
}

void jsonss_source_specification() #SourceSpecification : 
{
  String source;
  String location;
  String literal;
  Token t;
}
{ 
  (
     ( ( source = jsonss_source_name() <EXCLAMATION_POINT> )? ( location = jsonss_location_specification()  ) )
   | literal = string()
  )
  
  { 
     jjtThis.source = source;
     jjtThis.location = location;
     jjtThis.literal = literal;
  }
}

void jsonss_reference(int defaultReferenceType) #Reference : {}
{
   <AT> jsonss_source_specification()
       ( LOOKAHEAD(2) 
         <OPEN_PAREN>
            jsonss_reference_directive() ( jsonss_reference_directive() ) *
         <CLOSE_PAREN>
       )?
  {
    jjtThis.defaultReferenceDirectives = new DefaultReferenceDirectives(
                        defaultReferenceType,
                        defaultLocationValue, defaultLiteralValue,
                        defaultShiftSetting, defaultEmptyLocationSetting,
                        defaultEmptyLiteralSetting);
  }
}

void jsonss_reference_directive() #ReferenceDirective : {}
{
  (  jsonss_reference_type_directive()
   | jsonss_default_location_value_directive() 
   | jsonss_default_literal_value_directive() 
   | jsonss_empty_literal_directive()
   | jsonss_empty_location_directive()
   | jsonss_shift_directive()
   | jsonss_value_extraction_function()
  ) 
}

int jsonss_reference_type_directive() #ReferenceTypeDirective : 
{
  Token t;
  int referenceType;
}
{
  (
     t = <EOF> { referenceType = t.kind; }
  ) 

  {
    jjtThis.referenceType = referenceType;
    return referenceType;
  }
}

int jsonss_empty_location_directive() #EmptyLocationDirective :
{
  Token t;
  int emptyLocationSetting;
}
{
  (
     t = <ERROR_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
   | t = <WARNING_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
   | t = <SKIP_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
   | t = <PROCESS_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
  )

  {
    jjtThis.emptyLocationSetting = emptyLocationSetting;
    return emptyLocationSetting;
  }
}

int jsonss_empty_literal_directive() #EmptyLiteralDirective :
{
  Token t;
  int emptyLiteralSetting;
}
{
  (
     t = <ERROR_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
   | t = <WARNING_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
   | t = <SKIP_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
   | t = <PROCESS_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
  )

  {
    jjtThis.emptyLiteralSetting = emptyLiteralSetting;
    emptyLiteralSetting = emptyLiteralSetting;
    return emptyLiteralSetting;
  }
}

int jsonss_shift_directive() #ShiftDirective :
{
  Token t;
  int shiftSetting;
}
{
  (
     t = <SHIFT_UP> { shiftSetting = t.kind; }
   | t = <SHIFT_DOWN> { shiftSetting = t.kind; }
   | t = <SHIFT_LEFT> { shiftSetting = t.kind; }
   | t = <SHIFT_RIGHT> { shiftSetting = t.kind; }
   | t = <NO_SHIFT> { shiftSetting = t.kind; }
  )

  {
    jjtThis.shiftSetting = shiftSetting;
    return shiftSetting;
  }
}

void jsonss_default_literal_value_directive() #DefaultLiteralValueDirective :
{
  String literalValue;
}
{
  <DEFAULT_LITERAL_VALUE> <EQUAL> literalValue = string()

  {
    jjtThis.defaultLiteralValue = literalValue;
  }
}

void jsonss_default_location_value_directive() #DefaultLocationValueDirective :
{
  String locationValue;
}
{
  <DEFAULT_LOCATION_VALUE> <EQUAL> locationValue = string()

  {
    jjtThis.defaultLocationValue = locationValue;
  }
}

void jsonss_value_extraction_function() #ValueExtractionFunction:
{
  Token t;
  int functionID;
}
{
  ((
    ( 
       t = <TO_UPPER_CASE> { functionID = t.kind; }
     | t = <TO_LOWER_CASE> { functionID = t.kind; }
     | t = <TRIM> { functionID = t.kind; }
     | t = <REVERSE> { functionID = t.kind; }
     | t = <CAPTURING> { functionID = t.kind; }
     | t = <REPLACE> { functionID = t.kind; }
     | t = <REPLACE_ALL> { functionID = t.kind; }
     | t = <REPLACE_FIRST> { functionID = t.kind; }
     | t = <APPEND> { functionID = t.kind; }
     | t = <PREPEND> { functionID = t.kind; }
    ) ( LOOKAHEAD(2) <OPEN_PAREN> jsonss_value_extraction_function_argument() ( <COMMA> jsonss_value_extraction_function_argument() )* <CLOSE_PAREN> )?
   )
   |
   ( <OPEN_BRACKET> ( LOOKAHEAD(2) jsonss_value_extraction_function_argument() ( <COMMA> jsonss_value_extraction_function_argument() )* )? <CLOSE_BRACKET> )
     { functionID = CAPTURING; } 
  )
  {
    jjtThis.functionID = functionID;
  }
}

void jsonss_value_extraction_function_argument() #ValueExtractionFunctionArgument : {}
{
  jsonss_reference(JSON_STRING) | string()
}

String jsonss_source_name() : 
{
  Token t;
}
{
  t = <QUOTED_NAME_LITERAL> 

  {
    String s = t.image;
    return s.substring(1, s.length() - 1);
  }
}

void string(): 
{
  Token t;
}
{
  t = <STRING> 

  {
    String s = t.image;
    return s;
  }
}
