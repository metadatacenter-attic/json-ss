
options {
  LOOKAHEAD = 1;
  IGNORE_CASE = true;
  STATIC = false;
  USER_TOKEN_MANAGER=false;
  USER_CHAR_STREAM=false;

  // JJTree options

  MULTI=true;
  NODE_DEFAULT_VOID = true;
}

PARSER_BEGIN(JSONSSParser)

package org.metadatacenter.jsonss.parser;

import org.metadatacenter.jsonss.core.settings.ReferenceSettings;

import java.util.*;

public class JSONSSParser 
{
  private String defaultLocationValue;
  private String defaultLiteralValue;
  private int defaultReferenceType;
  private int defaultShiftSetting;
  private int defaultEmptyLocationSetting;
  private int defaultEmptyLiteralSetting;
  
  private ReferenceSettings referenceSettings;
  
  public JSONSSParser(java.io.InputStream stream, ReferenceSettings referenceSettings, int unused)
  {
    this(stream);
    changeGlobalReferenceSettings(referenceSettings);
  }

  public void changeGlobalReferenceSettings(ReferenceSettings referenceSettings)
  {
    defaultLocationValue = referenceSettings.getDefaultLocationValue();
    defaultLiteralValue = referenceSettings.getDefaultLiteralValue();
    defaultReferenceType = referenceSettings.getReferenceTypeSetting().getConstant();
    defaultShiftSetting = referenceSettings.getShiftSetting().getConstant();
    defaultEmptyLocationSetting = referenceSettings.getEmptyLocationSetting().getConstant();
    defaultEmptyLiteralSetting = referenceSettings.getEmptyLiteralSetting().getConstant();
  }
}

PARSER_END(JSONSSParser)

/* White space */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* Comments */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN: { <CELL_WILDCARD: "*"> }

TOKEN: { <LOCATION: "Location"> }

TOKEN: {<TRUE: "true" | "TRUE">}
TOKEN: {<FALSE: "false" | "FALSE">}

TOKEN: { <NULL: "null" > }
TOKEN: { <LITERAL: "Literal"> }
TOKEN: { <UNTYPED: "Untyped"> }

TOKEN: { <JSON_BOOLEAN: "boolean" > }
TOKEN: { <JSON_STRING: "string" > }
TOKEN: { <JSON_BYTE: "byte" > }
TOKEN: { <JSON_SHORT: "short" > }
TOKEN: { <JSON_INTEGER: "integer" > }
TOKEN: { <JSON_LONG: "long" > }
TOKEN: { <JSON_FLOAT: "float" > }
TOKEN: { <JSON_DOUBLE: "double" > }

TOKEN: { <TO_UPPER_CASE: "toUpperCase"> }
TOKEN: { <TO_LOWER_CASE: "toLowerCase"> }
TOKEN: { <TRIM: "trim"> }
TOKEN: { <CAPTURING: "capturing"> }
TOKEN: { <REVERSE: "reverse"> }
TOKEN: { <REPLACE: "replace"> }
TOKEN: { <REPLACE_ALL: "replaceAll"> }
TOKEN: { <REPLACE_FIRST: "replaceFirst"> }
TOKEN: { <APPEND: "append"> }
TOKEN: { <PREPEND: "prepend"> }

TOKEN: { <NO_SHIFT: "NoShift"> }
TOKEN: { <SHIFT_UP: "ShiftUp"> }
TOKEN: { <SHIFT_DOWN: "ShiftDown"> }
TOKEN: { <SHIFT_LEFT: "ShiftLeft"> }
TOKEN: { <SHIFT_RIGHT: "ShiftRight"> }

TOKEN: { <ERROR_IF_EMPTY_LOCATION: "ErrorIfEmptyLocation"> }
TOKEN: { <WARNING_IF_EMPTY_LOCATION: "WarningIfEmptyLocation"> }
TOKEN: { <SKIP_IF_EMPTY_LOCATION: "SkipIfEmptyLocation"> }
TOKEN: { <PROCESS_IF_EMPTY_LOCATION: "ProcessIfEmptyLocation"> }

TOKEN: { <PROCESS_IF_EMPTY_LITERAL: "ProcessIfEmptyLiteral"> }
TOKEN: { <ERROR_IF_EMPTY_LITERAL: "ErrorIfEmptyLiteral"> }
TOKEN: { <WARNING_IF_EMPTY_LITERAL: "WarningIfEmptyLiteral"> }
TOKEN: { <SKIP_IF_EMPTY_LITERAL: "SkipIfEmptyLiteral"> }

TOKEN: { <DEFAULT_LOCATION_VALUE: "DefaultLocationValue"> }
TOKEN: { <DEFAULT_LITERAL_VALUE: "DefaultLiteralValue"> }

TOKEN:
{
  <STRING_LITERAL: "\"" (~["\""])* ("\"\"" (~["\""])*)* ("\\\"")* "\"" >
| <QUOTED_NAME_LITERAL: "'" (~["'"])* ("''" (~["'"])*)* "'" >
| <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_" | "-" | "#" | "." | ":" | "/" )* | "'" (~["'"])* "'"> 
| <INTEGER_LITERAL: (["-"])? (<DIGIT>)+ > 
| <LONG_LITERAL: (["-"])? (<DIGIT>)+> 
| <FLOAT_LITERAL:   (["-"])? (<DIGIT>)+ "." (<DIGIT>)+ (<EXPONENT>)?
                  | (["-"])? "." (<DIGIT>)+ (<EXPONENT>)?
                  | (["-"])? (<DIGIT>)+ <EXPONENT>
                  | (["-"])? (<DIGIT>)+ (<EXPONENT>)? > 
|
  <#LETTER: [ "a"-"z", "A"-"Z" ]>
|
  <#DIGIT: ["0"-"9"] >
| 
  <#EXPONENT: ["e", "E"] (["+", "-"])? (<DIGIT>)+ >
| 
  <LOCATION_SPECIFICATION: (<LETTER> | <DIGIT> | "_" | "-" | "#" | "." | ":" | "/" | "*" )+ | "'" (~["'"])* "'"> 
}

SimpleNode expression() #Expression : {}
{
  <EOF>
  {
     return jjtThis;
  }
}

void literal() #Literal : {}
{
  (  integer_literal() 
   | float_literal() 
   | boolean_literal() 
   | string_literal() 
  )
} 

void integer_literal() #IntegerLiteral :
{
  Token t;
}
{
  t = <INTEGER_LITERAL>

  {
    jjtThis.value = Integer.valueOf(token.image);
  }
}

void float_literal() #FloatLiteral :
{
  Token t;
}
{
  t = <FLOAT_LITERAL>

  {
    jjtThis.value = Float.valueOf(token.image);
  }
}


String string() : 
{
  Token t;
}
{
  t = <STRING_LITERAL> 

  {
    String s = t.image;
    return s.substring(1, s.length() - 1);
  }
}

void string_literal() #StringLiteral :
{
  String value;
}
{
  value = string()

  {
    jjtThis.value = value;
  }
}

void boolean_literal() #BooleanLiteral :
{
  boolean value;
}
{
  ( <TRUE> { value = true; } | <FALSE> { value = false; } )

  {
    jjtThis.value = value;
  }
}

String location_specification() :
{
  Token t;
}
{
  t = <LOCATION_SPECIFICATION>

  { return t.image; }
}

void source_specification() #SourceSpecification : 
{
  String source = null;
  String location = null;
  String literal = null;
  Token t;
}
{ 
  (
     ( ( source = quoted_name() "!" )? ( location = location_specification()  ) )
   | literal = string()
  )

  { 
     jjtThis.source = source;
     jjtThis.location = location;
     jjtThis.literal = literal;
  }
}

int integer_value() :
{
  Token t;
}
{
  t=<INTEGER_LITERAL>
  {
    return Integer.parseInt(t.image);
  }
}

void reference(int defaultReferenceType) #Reference : {}
{
   "@" source_specification()
       ( LOOKAHEAD(2) 
         "(" 
            reference_directive() ( reference_directive() ) *
         ")"
       )?
  {
    jjtThis.defaultReferenceDirectives = new DefaultReferenceDirectives(
                        defaultReferenceType,
                        defaultLocationValue, defaultLiteralValue,
                        defaultShiftSetting, defaultEmptyLocationSetting,
                        defaultEmptyLiteralSetting);
  }
}

void reference_directive() #ReferenceDirective : {}
{
  (  reference_type_directive()
   | default_location_value_directive() 
   | default_literal_value_directive() 
   | empty_literal_directive()
   | empty_location_directive()
   | shift_directive()
   | value_extraction_function()
  ) 
}

int reference_type_directive() #ReferenceTypeDirective : 
{
  Token t;
  int referenceType;
}
{
  (
     t = <EOF> { referenceType = t.kind; }
  ) 

  {
    jjtThis.referenceType = referenceType;
    return referenceType;
  }
}

int empty_location_directive() #EmptyLocationDirective :
{
  Token t;
  int emptyLocationSetting;
}
{
  (
     t = <ERROR_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
   | t = <WARNING_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
   | t = <SKIP_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
   | t = <PROCESS_IF_EMPTY_LOCATION> { emptyLocationSetting = t.kind; }
  )

  {
    jjtThis.emptyLocationSetting = emptyLocationSetting;
    return emptyLocationSetting;
  }
}

int empty_literal_directive() #EmptyLiteralDirective :
{
  Token t;
  int emptyLiteralSetting;
}
{
  (
     t = <ERROR_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
   | t = <WARNING_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
   | t = <SKIP_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
   | t = <PROCESS_IF_EMPTY_LITERAL> { emptyLiteralSetting = t.kind; }
  )

  {
    jjtThis.emptyLiteralSetting = emptyLiteralSetting;
    emptyLiteralSetting = emptyLiteralSetting;
    return emptyLiteralSetting;
  }
}

int shift_directive() #ShiftDirective :
{
  Token t;
  int shiftSetting;
}
{
  (
     t = <SHIFT_UP> { shiftSetting = t.kind; }
   | t = <SHIFT_DOWN> { shiftSetting = t.kind; }
   | t = <SHIFT_LEFT> { shiftSetting = t.kind; }
   | t = <SHIFT_RIGHT> { shiftSetting = t.kind; }
   | t = <NO_SHIFT> { shiftSetting = t.kind; }
  )

  {
    jjtThis.shiftSetting = shiftSetting;
    return shiftSetting;
  }
}

void default_literal_value_directive() #DefaultLiteralValueDirective :
{
  String literalValue;
}
{
  <DEFAULT_LITERAL_VALUE> "=" literalValue = string()

  {
    jjtThis.defaultLiteralValue = literalValue;
  }
}

void default_location_value_directive() #DefaultLocationValueDirective :
{
  String locationValue;
}
{
  <DEFAULT_LOCATION_VALUE> "=" locationValue = string()

  {
    jjtThis.defaultLocationValue = locationValue;
  }
}

void value_extraction_function() #ValueExtractionFunction:
{
  Token t;
  int functionID;
}
{
  ((
    ( 
       t = <TO_UPPER_CASE> { functionID = t.kind; }
     | t = <TO_LOWER_CASE> { functionID = t.kind; }
     | t = <TRIM> { functionID = t.kind; }
     | t = <REVERSE> { functionID = t.kind; }
     | t = <CAPTURING> { functionID = t.kind; }
     | t = <REPLACE> { functionID = t.kind; }
     | t = <REPLACE_ALL> { functionID = t.kind; }
     | t = <REPLACE_FIRST> { functionID = t.kind; }
     | t = <APPEND> { functionID = t.kind; }
     | t = <PREPEND> { functionID = t.kind; }
    ) ( LOOKAHEAD(2) "(" value_extraction_function_argument() ( "," value_extraction_function_argument() )* ")" )?
   )
   |
   ( "[" ( LOOKAHEAD(2) value_extraction_function_argument() ( "," value_extraction_function_argument() )* )? "]" )  { functionID = CAPTURING; } 
  )
  {
    jjtThis.functionID = functionID;
  }
}

void value_extraction_function_argument() #ValueExtractionFunctionArgument : {}
{
  reference(JSON_STRING) | literal()
}


List<String> strings() :
{
  List<String> strings = new ArrayList<String>();
  String s;
}
{
  s = string() { strings.add(s); } ( "," s = string() { strings.add(s); } )*

  { return strings; }
} 

String quoted_name() : 
{
  Token t;
}
{
  t = <QUOTED_NAME_LITERAL> 

  {
    String s = t.image;
    return s.substring(1, s.length() - 1);
  }
}
